## 睡眠与唤醒

生产者-消费者(producer-consumer)：两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者(producer)，将信息放入缓冲区，另一个是消费者(consumer)，会从缓冲区中取出。

如果缓冲队列已满，那么当生产者仍想要将数据写入缓冲区的时候则让生产者睡眠，即阻塞生产者。等到消费者从缓冲区中取出一个或多个数据项时再唤醒它。

如果消费者试图从缓冲区中取数据，但是发现缓冲区为空时消费者也会睡眠，阻塞。直到生产者向其中放入一个新的数据。

唤醒丢失：假设缓冲区为空，此时消费者刚好读取count的值发现它为0 。此时调度程序决定暂停消费者并启动运行生产者。生产者生产了一条数据并把它放在缓冲区中，然后增加count的值，并注意到它的值是1。由于count为0，消费者必须处于睡眠状态，因此生产者调 用wakeup来唤醒消费者。但是消费者此时在逻辑上并没有睡眠，所以wakeup信号会丢失。因此当消费者下次启动后会查看之前读取的count值，发现它的值是0 然后在此进行睡眠。不久之后生产者会填满整个缓冲区，在这之后会阻塞，这样一来两个进程将永远睡眠下去。
