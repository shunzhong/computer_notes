## fork

fork函数实现的时候，实际上会把当前父进程的所有资源都克隆一份，包括地址空间、打开的文件描述符、程序计数器等、执行代码。

新派生的进程的表现行为和父进程近乎一样，为了区别两个不同的进程，实现者可以通过改变fork函数的栈空间值来判断，对应到程序中就是返回值的不同。

在调用该函数的进程（即为父进程）中返回的是新派生的进程ID号，在子进程中返回的值为0。想要知道当前执行的进程到底是父进程，还是子进程，只能通过返回值来进行判断。

```c
if(fork() == 0){
  do_child_process(); //子进程执行代码， 请求系统调用execve来执行另一个程序
}else{
  do_parent_process();  //父进程执行代码
}
```

当一个子进程退出时，系统内核还保留了该进程的若干信息，比如退出状态。这样的进程如果不回收，就会变成僵尸进程从而造成系统资源浪费。在Linux下，“僵尸”进程会被挂到进程号为1的init进程上。

父进程回收子进程的方式：

```c
pid_t wait(int *statloc);
pid_t waitpid(pid_t pid, int *statloc, int options);
```

- 返回值，表示已终止子进程的进程ID号

- statloc指针，返回子进程终止的实际状态

> 如果没有已终止的子进程，而是有一个或多个子进程在正常运行，那么wait将阻塞，直到第一个子进程终止。

进程退出时会发送一个捕捉信号SIGCHILD信号（默认忽略），因此我们可以通过注册一个信号处理函数的方式来回收子进程的资源。

```c
signal(SIGCHLD, sigchld_handler);　
```

