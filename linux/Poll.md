
## poll


**poll** 函数用于检测一组文件描述符（**F**ile **D**escriptor, **fd**）上的可读可写和出错事件，其函数签名如下：

```c
int poll(struct pollfd* fds, nfds_t nfds, int timeout);
```

**参数解释：**

- **fds**：指向一个结构体数组的首个元素的指针，每个数组元素都是一个 **struct pollfd** 结构，用于指定检测某个给定的 fd 的条件；

- **nfds**：参数 **fds** 结构体数组的长度

- **timeout**：表示 poll 函数的超时时间，单位为毫秒。

  > 如果是一个小于0的数，表示在有事件发生之前永远等待；
  >
  > 如果是0，表示不阻塞进程，立即返回；
  >
  > 如果是一个大于0的数，表示poll调用方等待指定的毫秒数后返回。

- 返回：若有就绪描述符则为其数目，若超时则为0，若出错则为-1



**struct pollfd** 结构体定义如下：

```c
struct pollfd {
    int   fd;         /* 描述符*/
    short events;     /* 描述符上待检测的事件类型组合 */
    short revents;    /* 检测后的得到的事件类型  */
};
```

> poll每次检测之后的结果不会修改原来的传入值，而是将结果保留在revents字段中，这样就不需要每次检测完都得重置待检测的描述字和感兴趣的事件。



## 总结：

不同点：在select里面，文件描述符的个数已经随着fd_set的实现而固定，没有办法对此进行配置；而在poll函数里，可以控制pollfd结构的数组大小自定义描述符数组的大小。

相同点：select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。

[[poll_server]]