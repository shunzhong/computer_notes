如果TCP连接的双方之间长时间不交换任何信息，则可能进入TCP连接半开放状态。保活功能就是试图检测到这种半开放的连接。

> 连接的半开放：连接双方其中一端已经中断，但另一方依旧保持连接。
> 比如：在客户端和服务端模式下如果客户端已经消失，使得在服务器上留下一个半开放连接来等待客户端的数据，从而造成连接资源的浪费。

如果一个给定的连接在两个小时之内没有任何动作，则向连接的另一端发送一个探查报文段。此时分为如下几种情况

1. 客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常工作的。服务器在两小时以后将保活定时器复位。如果在这期间有数据交互则定时器在交换数据后的未来2小时再复位。

2. 客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务器将不能够收到对探查的响应，并在75秒后超时。服务器总共发送10个这样的探查，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。

3. 客户主机崩溃并已经重新启动。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位（带有RST和ACK标志的响应），使得服务器终止这个连接。

![](assets/image-20200806175201081.png)

4. 客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与状态2之间的区别，它所能发现的就是没有收到探查的响应。
  
> 在第1种情况下，服务器的应用程序没有感觉到保活探查的发生。TCP层负责一切。这个过程对应用程序都是透明的，直至第2、3或4种情况发生，服务器应用程序收到来自它的TCP的差错报告。

linux 下可以配置通过如下参数设置TCP保活

```shell
#心跳保活时长(最长空载时间)
sysctl -w net.ipv4.tcp_keepalive_time=15    
#保活时心跳包发送次数(收不到对方响应时的重发次数)
sysctl -w net.ipv4.tcp_keepalive_probes=2
#保活时每次发包间隔 
sysctl -w net.ipv4.tcp_keepalive_intvl=3
```


